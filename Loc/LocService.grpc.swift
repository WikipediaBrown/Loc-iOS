//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: LocService.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import Foundation
import Dispatch
import SwiftGRPC
import SwiftProtobuf

internal protocol Locservice_LocUserOnlineCall: ClientCallUnary {}

fileprivate final class Locservice_LocUserOnlineCallBase: ClientCallUnaryBase<Locservice_OnlinePing, Locservice_OnlineResponse>, Locservice_LocUserOnlineCall {
  override class var method: String { return "/locservice.Loc/UserOnline" }
}

internal protocol Locservice_LocBroadcastCall: ClientCallClientStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Locservice_AudioBuffer, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Locservice_AudioBuffer, timeout: DispatchTime) throws

  /// Call this to close the connection and wait for a response. Blocking.
  func closeAndReceive() throws -> Locservice_Listeners
  /// Call this to close the connection and wait for a response. Nonblocking.
  func closeAndReceive(completion: @escaping (ResultOrRPCError<Locservice_Listeners>) -> Void) throws
}

internal extension Locservice_LocBroadcastCall {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Locservice_AudioBuffer, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Locservice_LocBroadcastCallBase: ClientCallClientStreamingBase<Locservice_AudioBuffer, Locservice_Listeners>, Locservice_LocBroadcastCall {
  override class var method: String { return "/locservice.Loc/Broadcast" }
}

internal protocol Locservice_LocUserOfflineCall: ClientCallUnary {}

fileprivate final class Locservice_LocUserOfflineCallBase: ClientCallUnaryBase<Locservice_OfflinePing, Locservice_OfflineResponse>, Locservice_LocUserOfflineCall {
  override class var method: String { return "/locservice.Loc/UserOffline" }
}

internal protocol Locservice_LocListenCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Locservice_AudioBuffer?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Locservice_AudioBuffer?>) -> Void) throws
}

internal extension Locservice_LocListenCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Locservice_AudioBuffer? { return try self._receive(timeout: timeout) }
}

fileprivate final class Locservice_LocListenCallBase: ClientCallServerStreamingBase<Locservice_Listener, Locservice_AudioBuffer>, Locservice_LocListenCall {
  override class var method: String { return "/locservice.Loc/Listen" }
}


/// Instantiate Locservice_LocServiceClient, then call methods of this protocol to make API calls.
internal protocol Locservice_LocService: ServiceClient {
  /// Synchronous. Unary.
  func userOnline(_ request: Locservice_OnlinePing) throws -> Locservice_OnlineResponse
  /// Asynchronous. Unary.
  func userOnline(_ request: Locservice_OnlinePing, completion: @escaping (Locservice_OnlineResponse?, CallResult) -> Void) throws -> Locservice_LocUserOnlineCall

  /// Asynchronous. Client-streaming.
  /// Use methods on the returned object to stream messages and
  /// to close the connection and wait for a final response.
  func broadcast(completion: ((CallResult) -> Void)?) throws -> Locservice_LocBroadcastCall

  /// Synchronous. Unary.
  func userOffline(_ request: Locservice_OfflinePing) throws -> Locservice_OfflineResponse
  /// Asynchronous. Unary.
  func userOffline(_ request: Locservice_OfflinePing, completion: @escaping (Locservice_OfflineResponse?, CallResult) -> Void) throws -> Locservice_LocUserOfflineCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func listen(_ request: Locservice_Listener, completion: ((CallResult) -> Void)?) throws -> Locservice_LocListenCall

}

internal final class Locservice_LocServiceClient: ServiceClientBase, Locservice_LocService {
  /// Synchronous. Unary.
  internal func userOnline(_ request: Locservice_OnlinePing) throws -> Locservice_OnlineResponse {
    return try Locservice_LocUserOnlineCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func userOnline(_ request: Locservice_OnlinePing, completion: @escaping (Locservice_OnlineResponse?, CallResult) -> Void) throws -> Locservice_LocUserOnlineCall {
    return try Locservice_LocUserOnlineCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Client-streaming.
  /// Use methods on the returned object to stream messages and
  /// to close the connection and wait for a final response.
  internal func broadcast(completion: ((CallResult) -> Void)?) throws -> Locservice_LocBroadcastCall {
    return try Locservice_LocBroadcastCallBase(channel)
      .start(metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func userOffline(_ request: Locservice_OfflinePing) throws -> Locservice_OfflineResponse {
    return try Locservice_LocUserOfflineCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func userOffline(_ request: Locservice_OfflinePing, completion: @escaping (Locservice_OfflineResponse?, CallResult) -> Void) throws -> Locservice_LocUserOfflineCall {
    return try Locservice_LocUserOfflineCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func listen(_ request: Locservice_Listener, completion: ((CallResult) -> Void)?) throws -> Locservice_LocListenCall {
    return try Locservice_LocListenCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

}

